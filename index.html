<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consulta Regulamentação Municipal - Nova lei de Licitações e Contratos Públicos</title>
    <link rel="icon" href="pesquisa.png" type="image/png">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 1600px;
            margin: 20px auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
        }
        .search-section, .filter-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        .search-section input[type="text"] {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }
        .search-section button, .filter-section select {
            padding: 12px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        .search-section button:hover, .filter-section select:hover {
            background-color: #2980b9;
        }
        .filter-section select {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        #resultsContainer, #documentDisplay {
            border-top: 1px solid #eee;
            padding-top: 20px;
            margin-top: 20px;
        }
        
        /* Estilo para os "quadrantes" de resultados de cada decreto */
        .decree-results-quadrant {
            background-color: #eaf3f8; /* Azul claro para o quadrante */
            border: 1px solid #cce7f4;
            padding: 20px;
            margin-bottom: 25px; /* Espaço entre os quadrantes de decretos diferentes */
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

  /* Cores de fundo alternadas para os blocos de decreto */
        .decree-results-quadrant:nth-of-type(odd) {
            background-color: #d5edf5; /* Azul claro */
        }

        .decree-results-quadrant:nth-of-type(even) {
            background-color: #f0ecbf; /* Um azul quase branco, mais sutil */

        }

        .decree-results-quadrant .decree-title {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.4em;
            margin-bottom: 15px;
            display: block;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db; /* Linha azul para destacar o título do decreto */
        }

        .document-card {
            background-color: #ffffff; /* Fundo branco para o card do artigo dentro do quadrante */
            border: 1px solid #eee;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .document-card .doc-reference {
            font-weight: bold;
            color: #34495e;
            margin-bottom: 10px;
            display: block;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .document-card .found-paragraph {
            line-height: 1.6;
            margin-top: 10px;
            margin-bottom: 0;
            overflow-wrap: break-word; /* Ajuda com quebras de linha em textos longos */
            color: #333; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1em; 
        }
        /* Ajuste para garantir que P, LI, Hx etc. dentro de .found-paragraph mantenham o estilo do documento original */
        .document-card .found-paragraph p,
        .document-card .found-paragraph ul,
        .document-card .found-paragraph ol,
        .document-card .found-paragraph li,
        .document-card .found-paragraph h1,
        .document-card .found-paragraph h2,
        .document-card .found-paragraph h3,
        .document-card .found-paragraph h4,
        .document-card .found-paragraph h5,
        .document-card .found-paragraph h6,
        .document-card .found-paragraph div,
        .document-card .found-paragraph span {
            margin: 0; 
            padding: 0;
            margin-bottom: 0.5em; 
            list-style-position: inside; 
        }

        .highlight {
            background-color: #ffe082; /* Amarelo mais suave */
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold; 
        }
        #documentDisplay h2 {
            text-align: left;
            margin-bottom: 15px;
        }
        #documentDisplay p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        .no-results {
            color: #777;
            text-align: center;
            padding: 20px;
        }
        .loading-message {
            text-align: center;
            padding: 20px;
            color: #555;
            font-style: italic;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Consulta Regulamentação Municipal - Nova lei de Licitações e Contratos Públicos</h1>
            <h1>Prefeitura Municipal de Goiana-PE</h1>

        <div class="search-section">
            <input type="text" id="searchInput" placeholder="Buscar por palavra-chave..." aria-label="Palavra-chave para busca">
            <button id="searchButton">Buscar</button>
        </div>

        <div class="filter-section">
            <label for="documentSelector" style="white-space: nowrap;">Ver Documento:</label>
            <select id="documentSelector">
                <option value="">Selecione um decreto/lei</option>
            </select>
        </div>

        <hr>

        <div id="resultsContainer">
            <p class="no-results">Digite uma palavra-chave para iniciar a busca ou selecione um documento acima para visualizá-lo.</p>
        </div>

        <div id="documentDisplay" style="display: none;">
        </div>
    </div>

    <script>
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const documentSelector = document.getElementById('documentSelector');
        const resultsContainer = document.getElementById('resultsContainer');
        const documentDisplay = document.getElementById('documentDisplay');

        let loadedDocuments = [];

        const documentFiles = [
            'DECRETO Nº 007-2024 - REGULAMENTA INEXIGIBILIDADE E DISPENSA.html',
            'DECRETO Nº 027-2024 – REGULA PESQUISA, SISTEMA E LICITAÇÃO NO CRITÉRIO DE MENOR PREÇO.html',
            'DECRETO Nº 038-2024 – REGULA ART. 79 DA LEI 14.133, 1º DE ABRIL 2021, SOBRE CREDENCIAMENTO A CONTRATAÇÃO DE BENS E SERVIÇOS NA ADM PÚBLICA.html',
            'DECRETO Nº 079-2023 - REGULAMENTA A LEI FEDERAL Nº 14.133 NOS ÓRGÃOS E ENTIDADES DA ADMINISTRAÇÃO VINCULADOS AO PODER EXECUTIVO MUNICIPAL.html',
        ];

        function normalizeText(text) {
            return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        }

        // Regex para identificar o início de um bloco de artigo/capítulo/seção.
        const articleBlockStartRegex = /^(artigo|art)\.?\s*((\d+)|([IVXLCDM]+))|^capítulo\s*((\d+)|([IVXLCDM]+))|^seção\s*((\d+)|([IVXLCDM]+))|^parágrafo\s+único|^\u00A7\s*\d+/i;

        async function loadDocuments() {
            resultsContainer.innerHTML = '<p class="loading-message">Carregando documentos...</p>';
            try {
                loadedDocuments = [];
                documentSelector.innerHTML = '<option value="">Selecione um decreto/lei</option>';

                const fetches = documentFiles.map(async file => {
                    try {
                        const response = await fetch(`decretos/${file}`);
                        if (!response.ok) {
                            throw new Error(`Erro ${response.status} ao carregar ${file}: ${response.statusText}`);
                        }
                        const htmlText = await response.text();

                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlText, 'text/html');

                        const docTitle = file.replace('.html', '');

                        // Extrair todos os elementos de bloco do body em ordem para facilitar a busca
                        const bodyElements = Array.from(doc.body.children);
                        const processedElements = bodyElements.map(element => {
                            return {
                                element: element, // Referência ao elemento original do DOM parseado
                                html: element.outerHTML,
                                text: element.textContent.trim(),
                                normalizedText: normalizeText(element.textContent.trim()),
                                isArticleStart: articleBlockStartRegex.test(element.textContent.trim())
                            };
                        });

                        loadedDocuments.push({
                            id: file, 
                            title: docTitle,
                            originalFullHtml: htmlText, 
                            parsedDoc: doc, // Armazena o DOM parseado para display completo
                            processedElements: processedElements // Lista de elementos de bloco com metadados
                        });

                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = docTitle;
                        documentSelector.appendChild(option);
                    } catch (innerError) {
                        console.error(`Falha ao carregar ou processar o arquivo "${file}":`, innerError);
                    }
                });

                await Promise.all(fetches);
                console.log('Documentos carregados com sucesso!', loadedDocuments);
                resultsContainer.innerHTML = '<p class="no-results">Digite uma palavra-chave para iniciar a busca ou selecione um documento acima para visualizá-lo.</p>';

            } catch (error) {
                console.error('Erro geral ao carregar documentos:', error);
                resultsContainer.innerHTML = '<p class="no-results" style="color: red;">Erro ao carregar os documentos. Verifique o console para mais detalhes.</p>';
            }
        }

        function performSearch() {
            const searchTerm = normalizeText(searchInput.value.trim());
            resultsContainer.innerHTML = ''; 
            documentDisplay.style.display = 'none'; 
            documentSelector.value = ""; 

            if (searchTerm.length < 2) {
                resultsContainer.innerHTML = '<p class="no-results">Digite pelo menos 2 caracteres para buscar.</p>';
                return;
            }

            const resultsByDecree = {}; 
            // Cuidado: a highlightRegex deve usar o searchTerm original para o destaque,
            // mas o normalizedText para a busca.
            const highlightRegex = new RegExp(`(${searchInput.value.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');

            loadedDocuments.forEach(docData => {
                const docTitle = docData.title;
                const processedElements = docData.processedElements;
                const foundOccurrences = [];

                processedElements.forEach((block, index) => {
                    if (block.normalizedText.includes(searchTerm)) {
                        let articleStartIndex = -1;
                        let articleTitle = 'Contexto sem Artigo Específico';

                        // Busca retroativa pelo início do artigo mais próximo
                        for (let i = index; i >= 0; i--) {
                            if (processedElements[i].isArticleStart) {
                                articleStartIndex = i;
                                articleTitle = processedElements[i].text.split('\n')[0].trim(); // Pega a primeira linha
                                break;
                            }
                        }

                        let htmlToDisplay = [];
                        if (articleStartIndex !== -1) {
                            // Coleta todos os blocos desde o início do artigo até o bloco atual (inclusive)
                            for (let i = articleStartIndex; i <= index; i++) {
                                htmlToDisplay.push(processedElements[i].html);
                            }
                        } else {
                            // Se não encontrou um Art.XX, exibe apenas o bloco encontrado
                            htmlToDisplay.push(block.html);
                        }

                        const tempDivForHighlight = document.createElement('div');
                        tempDivForHighlight.innerHTML = htmlToDisplay.join('\n');

                        // Agora, vamos encontrar o nó de texto *dentro* do tempDivForHighlight
                        // que corresponde ao conteúdo original do bloco encontrado (`block.text`)
                        // e aplicar o destaque apenas nele. Isso é mais robusto do que TreeWalker no full HTML.

                        // O desafio aqui é que `block.element` é do `parsedDoc` original, não de `tempDivForHighlight`.
                        // Precisamos iterar sobre os nós de texto dentro de `tempDivForHighlight`
                        // e aplicar o highlight onde a palavra-chave é encontrada.

                        // Percorrer os nós de texto dentro do tempDivForHighlight
                        const highlightWalker = document.createTreeWalker(
                            tempDivForHighlight, 
                            NodeFilter.SHOW_TEXT, 
                            null, 
                            false
                        );
                        let highlightNode;
                        const highlightNodesToReplace = [];

                        while (highlightNode = highlightWalker.nextNode()) {
                            const currentText = highlightNode.nodeValue;
                            const newText = currentText.replace(highlightRegex, '<span class="highlight">$&</span>');
                            if (currentText !== newText) {
                                highlightNodesToReplace.push({ node: highlightNode, newText: newText });
                            }
                        }

                        // Realiza as substituições
                        highlightNodesToReplace.forEach(item => {
                            const range = document.createRange();
                            range.selectNode(item.node);
                            const fragment = range.createContextualFragment(item.newText);
                            item.node.parentNode.replaceChild(fragment, item.node);
                        });

                        foundOccurrences.push({
                            html: tempDivForHighlight.innerHTML,
                            title: articleTitle
                        });
                    }
                }); // Fim do forEach processedElements

                if (foundOccurrences.length > 0) {
                    if (!resultsByDecree[docData.id]) {
                        resultsByDecree[docData.id] = {
                            title: docTitle,
                            foundArticles: []
                        };
                    }
                    resultsByDecree[docData.id].foundArticles.push(...foundOccurrences);
                }
            }); // Fim do forEach loadedDocuments

            let totalFoundArticles = 0;
            for (const docId in resultsByDecree) {
                if (resultsByDecree.hasOwnProperty(docId)) {
                    const decreeData = resultsByDecree[docId];
                    totalFoundArticles += decreeData.foundArticles.length;

                    let decreeHtml = `
                        <div class="decree-results-quadrant">
                            <span class="decree-title">Decreto/Lei: ${decreeData.title}</span>
                    `;

                    decreeData.foundArticles.forEach(foundArticle => { 
                        decreeHtml += `
                            <div class="document-card">
                                <span class="doc-reference">${foundArticle.title}:</span> 
                                <div class="found-paragraph">${foundArticle.html}</div>
                            </div>
                        `;
                    });

                    decreeHtml += `</div>`; 
                    resultsContainer.innerHTML += decreeHtml;
                }
            }

            if (totalFoundArticles === 0) {
                resultsContainer.innerHTML = `<p class="no-results">Nenhum resultado encontrado para "<strong>${searchInput.value}</strong>".</p>`;
            } else {
                resultsContainer.innerHTML = `<h2 style="text-align: left; color: #34495e;">Resultados da busca (${totalFoundArticles} encontrados)</h2>` + resultsContainer.innerHTML;
            }
        }

        function displaySelectedDocument() {
            const selectedFile = documentSelector.value;
            resultsContainer.innerHTML = ''; 
            searchInput.value = ''; 
            documentDisplay.style.display = 'block'; 

            if (selectedFile === "") {
                documentDisplay.innerHTML = '<p class="no-results">Selecione um documento para visualizá-lo.</p>';
                return;
            }

            const doc = loadedDocuments.find(d => d.id === selectedFile);
            if (doc) {
                documentDisplay.innerHTML = `<div class="document-full-content">${doc.originalFullHtml}</div>`;
            } else {
                documentDisplay.innerHTML = '<p class="no-results" style="color: red;">Erro: Documento não encontrado.</p>';
            }
        }

        document.addEventListener('DOMContentLoaded', loadDocuments);
        searchButton.addEventListener('click', performSearch);
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
        documentSelector.addEventListener('change', displaySelectedDocument);
    </script>

</body>
</html>
